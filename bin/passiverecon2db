#! /usr/bin/env python

# This file is part of IVRE.
# Copyright 2011 - 2014 Pierre LALET <pierre.lalet@cea.fr>
#
# IVRE is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# IVRE is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License
# along with IVRE. If not, see <http://www.gnu.org/licenses/>.

import ivre.db
import ivre.utils
import re
import hashlib

MAXVALLEN = ivre.utils.MAXVALLEN
SymantecUA = re.compile('[a-zA-Z0-9/+]{32,33}AAAAA$')
DigestAuthInfos = re.compile('(username|realm|algorithm|qop)=')


def preparerec(spec, ignorenets, neverignore):
    # First of all, let's see if we are supposed to ignore this spec,
    # and if so, do so.
    if ('addr' in spec and
        spec.get('source') not in neverignore.get(spec['recontype'], [])):
        for n in ignorenets.get(spec['recontype'], ()):
            if n[0] <= spec['addr'] <= n[1]:
                return None
    # Then, let's clean up the records.
    # Change Symantec's random user agents (matching SymantecUA) to
    # the constant string 'SymantecRandomUserAgent', to store
    # different SymantecUA for the same host & sensor in the same
    # records.
    if spec['recontype'] == 'HTTP_CLIENT_HEADER' and \
       spec.get('source') == 'USER-AGENT':
        if SymantecUA.match(spec['value']):
            spec['value'] = 'SymantecRandomUserAgent'
    # Change any Digest authorization header to remove non-constant
    # information. On one hand we loose the necessary information to
    # try to recover the passwords, but on the other hand we store
    # specs with different challenges but the same username, realm,
    # host and sensor in the same records.
    if spec['recontype'] in ['HTTP_CLIENT_HEADER',
                             'HTTP_CLIENT_HEADER_SERVER'] and \
        spec.get('source') in ['AUTHORIZATION',
                               'PROXY-AUTHORIZATION']:
        if spec['value'].startswith('Digest'):
            try:
                # we only keep relevant info
                v = filter(DigestAuthInfos.match,
                           spec['value'][6:].lstrip().split(','))
                spec['value'] = 'Digest ' + ','.join(v)
            except:
                pass
    # Finally we prepare the record to be stored. For that, we make
    # sure that no indexed value has a size greater than MAXVALLEN. If
    # so, we replace the value with its SHA1 hash and store the
    # original value in full[original column name].
    if len(spec['value']) > MAXVALLEN:
        spec['fullvalue'] = spec['value']
        spec['value'] = hashlib.sha1(spec['fullvalue']).hexdigest()
    if 'targetval' in spec and len(spec['targetval']) > MAXVALLEN:
        spec['fulltargetval'] = spec['targetval']
        spec['targetval'] = hashlib.sha1(spec['fulltargetval']).hexdigest()
    return spec


def handle_rec(sensor, ignorenets, neverignore,
               # these argmuments are provided by *<line.split()>
               ts, host, port, recon_type, source, value, targetval):
    ts = float(ts)
    recon_type = recon_type[14:]  # skip PassiveRecon::
    if host == '-':
        spec = {
            'targetval': targetval,
            'recontype': recon_type,
            'value': value
        }
    else:
        try:
            host = ivre.utils.ip2int(host)
        except:
            pass
        spec = {
            'addr': host,
            'recontype': recon_type,
            'value': value
        }
    if sensor is not None:
        spec.update({'sensor': sensor})
    if port != '-':
        spec.update({'port': int(port)})
    if source != '-':
        spec.update({'source': source})
    spec = preparerec(spec, ignorenets, neverignore)
    if spec is not None:
        ivre.db.db.passive.insert_or_update(
            ts, spec, getinfos=ivre.utils.passive_getinfos
        )

def main():
    import sys
    description = ('Update the database from output of the Bro script '
                   '"passiverecon"')
    try:
        import argparse
        parser = argparse.ArgumentParser(description=description)
    except ImportError:
        import optparse
        parser = optparse.OptionParser(description=description)
        parser.parse_args_orig = parser.parse_args
        parser.parse_args = lambda: parser.parse_args_orig()[0]
        parser.add_argument = parser.add_option
    parser.add_argument('--sensor', '-s', help='Sensor name')
    parser.add_argument('--ignore-spec', '-i',
                        help='Filename containing ignore rules')
    args = parser.parse_args()
    ignore_rules = {}
    if args.ignore_spec is not None:
        execfile(args.ignore_spec, ignore_rules)
    for l in sys.stdin:
        if not l or l.startswith('#'):
            continue
        if l.endswith('\n'):
            l = l[:-1]
        try:
            handle_rec(args.sensor,
                       ignore_rules.get('IGNORENETS', {}),
                       ignore_rules.get('NEVERIGNORE', {}),
                       *l.split('\t'))
        except:
            sys.stderr.write("WARNING: cannot parse line [%s]\n" % l)

if __name__ == '__main__':
    main()
